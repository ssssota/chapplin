import { mkdir, writeFile } from "node:fs/promises";
import { join, relative } from "node:path";
import type { Plugin, ResolvedConfig } from "vite";
import {
	DEFAULT_PROMPTS_DIR,
	DEFAULT_RESOURCES_DIR,
	DEFAULT_TOOLS_DIR,
} from "../../constants.js";
import { VIRTUAL_MODULE_ID } from "../../constants.js";
import type { ResolvedOptions } from "../types.js";
import { normalizePath } from "../utils.js";
import { collectFilesFromRoot } from "./file-collector.js";

/** Output directory for generated types */
const TYPE_GEN_DIR = ".chapplin/types";

export interface SyncTypeGenerationOptions {
	root: string;
	toolsDir?: string;
	resourcesDir?: string;
	promptsDir?: string;
}

export interface SyncTypeGenerationResult {
	tools: number;
	resources: number;
	prompts: number;
	outputDir: string;
}

export async function syncTypeGeneration(
	options: SyncTypeGenerationOptions,
): Promise<SyncTypeGenerationResult> {
	const root = options.root;
	const files = await collectFilesFromRoot(root, {
		toolsDir: options.toolsDir ?? DEFAULT_TOOLS_DIR,
		resourcesDir: options.resourcesDir ?? DEFAULT_RESOURCES_DIR,
		promptsDir: options.promptsDir ?? DEFAULT_PROMPTS_DIR,
	});

	const typeDefinitions = generateTypeDefinitions(
		root,
		files.tools.map((t) => ({
			path: t.path,
			relativePath: t.relativePath,
			name: t.name,
		})),
		files.resources.map((r) => ({
			path: r.path,
			relativePath: r.relativePath,
			name: r.name,
		})),
		files.prompts.map((p) => ({
			path: p.path,
			relativePath: p.relativePath,
			name: p.name,
		})),
	);

	const outputDir = join(root, TYPE_GEN_DIR);
	await mkdir(outputDir, { recursive: true });

	await writeFile(join(outputDir, "register.d.ts"), typeDefinitions.register, "utf-8");
	await writeFile(join(outputDir, "tools.d.ts"), typeDefinitions.tools, "utf-8");
	await writeFile(
		join(outputDir, "resources.d.ts"),
		typeDefinitions.resources,
		"utf-8",
	);
	await writeFile(join(outputDir, "prompts.d.ts"), typeDefinitions.prompts, "utf-8");

	return {
		tools: files.tools.length,
		resources: files.resources.length,
		prompts: files.prompts.length,
		outputDir,
	};
}

/**
 * Plugin that generates TypeScript type definitions
 */
export function typeGeneration(opts: ResolvedOptions): Plugin {
	let config: ResolvedConfig;

	return {
		name: "chapplin:type-generation",
		configResolved(resolvedConfig) {
			config = resolvedConfig;
		},
		async buildStart() {
			await syncTypeGeneration({
				root: config.root,
				toolsDir: opts.toolsDir,
				resourcesDir: opts.resourcesDir,
				promptsDir: opts.promptsDir,
			});

			if (config.command === "serve") {
				config.logger.info(
					`[chapplin] Generated type definitions in ${TYPE_GEN_DIR}/`,
				);
			}
		},
	};
}

interface FileInfo {
	path: string;
	relativePath: string;
	name: string;
}

/**
 * Generate TypeScript type definitions
 */
function generateTypeDefinitions(
	root: string,
	tools: FileInfo[],
	resources: FileInfo[],
	prompts: FileInfo[],
): {
	register: string;
	tools: string;
	resources: string;
	prompts: string;
} {
	const header = [
		"// This file is auto-generated by chapplin. Do not edit manually.",
		"// To regenerate, run `chapplin sync`, `vite build`, or `vite dev`",
		"",
	].join("\n");

	// Generate module declaration for chapplin:register
	const registerLines = [
		header,
		`declare module "${VIRTUAL_MODULE_ID}" {`,
		'  import type { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";',
		"  /**",
		"   * Register all tools, resources, and prompts from this project onto the given MCP server.",
		"   */",
		"  export function register(server: McpServer): void;",
		"}",
		"",
	];

	// Generate Tools interface
	const toolsLines = [
		header,
		'declare module "chapplin:tools" {',
		"  export interface Tools {",
	];

	for (const tool of tools) {
		const importPath = `../${normalizePath(relative(root, tool.path)).replace(/\.(ts|tsx)$/, "")}`;

		toolsLines.push(`    "${tool.name}": {`);
		toolsLines.push(`      /** Import path: ${importPath} */`);
		toolsLines.push(
			`      input: typeof import("${importPath}").tool.config extends { inputSchema: infer S } ? import("zod").infer<import("zod").ZodObject<S>> : Record<string, unknown>;`,
		);
		toolsLines.push(
			`      output: typeof import("${importPath}").tool.config extends { outputSchema: infer S } ? import("zod").infer<import("zod").ZodObject<S>> : Record<string, unknown>;`,
		);
		toolsLines.push("    };");
	}

	toolsLines.push("  }");
	toolsLines.push("");

	// Export tool names as a union type
	if (tools.length > 0) {
		const toolNames = tools.map((t) => `"${t.name}"`).join(" | ");
		toolsLines.push(`  export type ToolName = ${toolNames};`);
	} else {
		toolsLines.push("  export type ToolName = never;");
	}

	toolsLines.push("}");
	toolsLines.push("");

	// Generate Resources interface
	const resourcesLines = [
		header,
		'declare module "chapplin:resources" {',
		"  export interface Resources {",
	];

	for (const resource of resources) {
		const importPath = `../${normalizePath(relative(root, resource.path)).replace(/\.ts$/, "")}`;

		resourcesLines.push(`    "${resource.name}": {`);
		resourcesLines.push(
			`      uri: typeof import("${importPath}").resource.config extends { uri: infer U } ? U : string;`,
		);
		resourcesLines.push("    };");
	}

	resourcesLines.push("  }");
	resourcesLines.push("");

	if (resources.length > 0) {
		const resourceNames = resources.map((r) => `"${r.name}"`).join(" | ");
		resourcesLines.push(`  export type ResourceName = ${resourceNames};`);
	} else {
		resourcesLines.push("  export type ResourceName = never;");
	}

	resourcesLines.push("}");
	resourcesLines.push("");

	// Generate Prompts interface
	const promptsLines = [
		header,
		'declare module "chapplin:prompts" {',
		"  export interface Prompts {",
	];

	for (const prompt of prompts) {
		const importPath = `../${normalizePath(relative(root, prompt.path)).replace(/\.ts$/, "")}`;

		promptsLines.push(`    "${prompt.name}": {`);
		promptsLines.push(
			`      args: typeof import("${importPath}").prompt.config extends { argsSchema: infer S } ? import("zod").infer<import("zod").ZodObject<S>> : Record<string, unknown>;`,
		);
		promptsLines.push("    };");
	}

	promptsLines.push("  }");
	promptsLines.push("");

	if (prompts.length > 0) {
		const promptNames = prompts.map((p) => `"${p.name}"`).join(" | ");
		promptsLines.push(`  export type PromptName = ${promptNames};`);
	} else {
		promptsLines.push("  export type PromptName = never;");
	}

	promptsLines.push("}");
	promptsLines.push("");

	return {
		register: registerLines.join("\n"),
		tools: toolsLines.join("\n"),
		resources: resourcesLines.join("\n"),
		prompts: promptsLines.join("\n"),
	};
}
