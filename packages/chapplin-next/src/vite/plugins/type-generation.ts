import { mkdir, writeFile } from "node:fs/promises";
import { join, relative } from "node:path";
import type { Plugin, ResolvedConfig } from "vite";
import { VIRTUAL_MODULE_ID } from "../../constants.js";
import type { ResolvedOptions } from "../types.js";
import { getCollectedFiles } from "./file-collector.js";

/** Output directory for generated types */
const TYPE_GEN_DIR = ".chapplin/types";

/**
 * Plugin that generates TypeScript type definitions
 */
export function typeGeneration(_opts: ResolvedOptions): Plugin {
	let config: ResolvedConfig;

	return {
		name: "chapplin:type-generation",
		configResolved(resolvedConfig) {
			config = resolvedConfig;
		},
		async buildStart() {
			const files = await getCollectedFiles();
			const root = config.root;

			// Generate type definitions using import-based type inference
			const typeDefinitions = generateTypeDefinitions(
				root,
				files.tools.map((t) => ({
					path: t.path,
					relativePath: t.relativePath,
					name: t.name,
				})),
				files.resources.map((r) => ({
					path: r.path,
					relativePath: r.relativePath,
					name: r.name,
				})),
				files.prompts.map((p) => ({
					path: p.path,
					relativePath: p.relativePath,
					name: p.name,
				})),
			);

			// Write to .chapplin/types/ directory
			const outputDir = join(root, TYPE_GEN_DIR);
			await mkdir(outputDir, { recursive: true });

			// Write each module to a separate file
			await writeFile(
				join(outputDir, "register.d.ts"),
				typeDefinitions.register,
				"utf-8",
			);
			await writeFile(
				join(outputDir, "tools.d.ts"),
				typeDefinitions.tools,
				"utf-8",
			);
			await writeFile(
				join(outputDir, "resources.d.ts"),
				typeDefinitions.resources,
				"utf-8",
			);
			await writeFile(
				join(outputDir, "prompts.d.ts"),
				typeDefinitions.prompts,
				"utf-8",
			);

			if (config.command === "serve") {
				config.logger.info(
					`[chapplin] Generated type definitions in ${TYPE_GEN_DIR}/`,
				);
			}
		},
	};
}

interface FileInfo {
	path: string;
	relativePath: string;
	name: string;
}

/**
 * Generate TypeScript type definitions
 */
function generateTypeDefinitions(
	root: string,
	tools: FileInfo[],
	resources: FileInfo[],
	prompts: FileInfo[],
): {
	register: string;
	tools: string;
	resources: string;
	prompts: string;
} {
	const header = [
		"// This file is auto-generated by chapplin. Do not edit manually.",
		"// To regenerate, run `vite build` or `vite dev`",
		"",
	].join("\n");

	// Generate module declaration for chapplin:register
	const registerLines = [
		header,
		`declare module "${VIRTUAL_MODULE_ID}" {`,
		'  import type { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";',
		"  /**",
		"   * Register all tools, resources, and prompts from this project onto the given MCP server.",
		"   */",
		"  export function register(server: McpServer): void;",
		"}",
		"",
	];

	// Generate Tools interface
	const toolsLines = [
		header,
		'declare module "chapplin:tools" {',
		"  export interface Tools {",
	];

	for (const tool of tools) {
		const importPath = `../${relative(root, tool.path).replace(/\.(ts|tsx)$/, "")}`;

		toolsLines.push(`    "${tool.name}": {`);
		toolsLines.push(`      /** Import path: ${importPath} */`);
		toolsLines.push(
			`      input: typeof import("${importPath}").tool.config extends { inputSchema: infer S } ? import("zod").infer<import("zod").ZodObject<S>> : Record<string, unknown>;`,
		);
		toolsLines.push(
			`      output: typeof import("${importPath}").tool.config extends { outputSchema: infer S } ? import("zod").infer<import("zod").ZodObject<S>> : Record<string, unknown>;`,
		);
		toolsLines.push("    };");
	}

	toolsLines.push("  }");
	toolsLines.push("");

	// Export tool names as a union type
	if (tools.length > 0) {
		const toolNames = tools.map((t) => `"${t.name}"`).join(" | ");
		toolsLines.push(`  export type ToolName = ${toolNames};`);
	} else {
		toolsLines.push("  export type ToolName = never;");
	}

	toolsLines.push("}");
	toolsLines.push("");

	// Generate Resources interface
	const resourcesLines = [
		header,
		'declare module "chapplin:resources" {',
		"  export interface Resources {",
	];

	for (const resource of resources) {
		const importPath = `../${relative(root, resource.path).replace(/\.ts$/, "")}`;

		resourcesLines.push(`    "${resource.name}": {`);
		resourcesLines.push(
			`      uri: typeof import("${importPath}").resource.config extends { uri: infer U } ? U : string;`,
		);
		resourcesLines.push("    };");
	}

	resourcesLines.push("  }");
	resourcesLines.push("");

	if (resources.length > 0) {
		const resourceNames = resources.map((r) => `"${r.name}"`).join(" | ");
		resourcesLines.push(`  export type ResourceName = ${resourceNames};`);
	} else {
		resourcesLines.push("  export type ResourceName = never;");
	}

	resourcesLines.push("}");
	resourcesLines.push("");

	// Generate Prompts interface
	const promptsLines = [
		header,
		'declare module "chapplin:prompts" {',
		"  export interface Prompts {",
	];

	for (const prompt of prompts) {
		const importPath = `../${relative(root, prompt.path).replace(/\.ts$/, "")}`;

		promptsLines.push(`    "${prompt.name}": {`);
		promptsLines.push(
			`      args: typeof import("${importPath}").prompt.config extends { argsSchema: infer S } ? import("zod").infer<import("zod").ZodObject<S>> : Record<string, unknown>;`,
		);
		promptsLines.push("    };");
	}

	promptsLines.push("  }");
	promptsLines.push("");

	if (prompts.length > 0) {
		const promptNames = prompts.map((p) => `"${p.name}"`).join(" | ");
		promptsLines.push(`  export type PromptName = ${promptNames};`);
	} else {
		promptsLines.push("  export type PromptName = never;");
	}

	promptsLines.push("}");
	promptsLines.push("");

	return {
		register: registerLines.join("\n"),
		tools: toolsLines.join("\n"),
		resources: resourcesLines.join("\n"),
		prompts: promptsLines.join("\n"),
	};
}
