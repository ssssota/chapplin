import { mkdir, readFile, writeFile } from "node:fs/promises";
import { join, relative } from "node:path";
import type { Plugin, ResolvedConfig } from "vite";
import { VIRTUAL_MODULE_ID } from "../../constants.js";
import {
	parsePromptFile,
	parseResourceFile,
	parseToolFile,
} from "../parser.js";
import type { Options } from "../types.js";
import { getCollectedFiles } from "./file-collector.js";

/** Output directory for generated types */
const TYPE_GEN_DIR = ".chapplin/types";

/**
 * Plugin that generates TypeScript type definitions
 */
export function typeGeneration(_opts: Options): Plugin {
	let config: ResolvedConfig;

	return {
		name: "chapplin:type-generation",
		configResolved(resolvedConfig) {
			config = resolvedConfig;
		},
		async buildStart() {
			const files = await getCollectedFiles();
			const root = config.root;

			// Parse all files to extract type information
			const toolInfos = await Promise.all(
				files.tools.map(async (tool) => {
					const code = await readFile(tool.path, "utf-8");
					const parsed = await parseToolFile(tool.path, code);
					return {
						...tool,
						...parsed,
					};
				}),
			);

			const resourceInfos = await Promise.all(
				files.resources.map(async (resource) => {
					const code = await readFile(resource.path, "utf-8");
					const parsed = await parseResourceFile(resource.path, code);
					return {
						...resource,
						...parsed,
					};
				}),
			);

			const promptInfos = await Promise.all(
				files.prompts.map(async (prompt) => {
					const code = await readFile(prompt.path, "utf-8");
					const parsed = await parsePromptFile(prompt.path, code);
					return {
						...prompt,
						...parsed,
					};
				}),
			);

			// Generate type definitions
			const typeDefinitions = generateTypeDefinitions(
				root,
				toolInfos,
				resourceInfos,
				promptInfos,
			);

			// Write to .chapplin/types/ directory
			const outputDir = join(root, TYPE_GEN_DIR);
			await mkdir(outputDir, { recursive: true });

			// Write each module to a separate file
			await writeFile(
				join(outputDir, "mcp-server.d.ts"),
				typeDefinitions.mcpServer,
				"utf-8",
			);
			await writeFile(
				join(outputDir, "tools.d.ts"),
				typeDefinitions.tools,
				"utf-8",
			);
			await writeFile(
				join(outputDir, "resources.d.ts"),
				typeDefinitions.resources,
				"utf-8",
			);
			await writeFile(
				join(outputDir, "prompts.d.ts"),
				typeDefinitions.prompts,
				"utf-8",
			);

			if (config.command === "serve") {
				config.logger.info(
					`[chapplin] Generated type definitions in ${TYPE_GEN_DIR}/`,
				);
			}
		},
	};
}

interface ToolInfo {
	path: string;
	relativePath: string;
	name: string | null;
	hasApp: boolean;
	inputSchemaSource: string | null;
	outputSchemaSource: string | null;
}

interface ResourceInfo {
	path: string;
	relativePath: string;
	name: string | null;
	uri: string | null;
}

interface PromptInfo {
	path: string;
	relativePath: string;
	name: string | null;
	argsSchemaSource: string | null;
}

/**
 * Generate TypeScript type definitions
 */
function generateTypeDefinitions(
	root: string,
	tools: ToolInfo[],
	resources: ResourceInfo[],
	prompts: PromptInfo[],
): {
	mcpServer: string;
	tools: string;
	resources: string;
	prompts: string;
} {
	const header = [
		"// This file is auto-generated by chapplin. Do not edit manually.",
		"// To regenerate, run `vite build` or `vite dev`",
		"",
	].join("\n");

	// Generate module declaration for chapplin:mcp-server
	const mcpServerLines = [
		header,
		`declare module "${VIRTUAL_MODULE_ID}" {`,
		'  import type { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";',
		"  /**",
		"   * Create a new MCP server instance with all registered tools, resources, and prompts.",
		"   * Each call creates a fresh instance, which is needed for transports like StreamableHTTPTransport",
		"   * that require a new server per request.",
		"   */",
		"  export function createMcpServer(): McpServer;",
		"  export default createMcpServer;",
		"}",
		"",
	];

	// Generate Tools interface
	const toolsLines = [
		header,
		'declare module "chapplin:tools" {',
		"  export interface Tools {",
	];

	for (const tool of tools) {
		const toolName = tool.name || tool.relativePath.replace(/\.(ts|tsx)$/, "");
		const importPath = `../${relative(root, tool.path).replace(/\.(ts|tsx)$/, "")}`;

		toolsLines.push(`    "${toolName}": {`);
		toolsLines.push(`      /** Import path: ${importPath} */`);
		toolsLines.push(
			`      input: typeof import("${importPath}").tool.config extends { inputSchema: infer S } ? import("zod").infer<import("zod").ZodObject<S>> : Record<string, unknown>;`,
		);
		toolsLines.push(
			`      output: typeof import("${importPath}").tool.config extends { outputSchema: infer S } ? import("zod").infer<import("zod").ZodObject<S>> : Record<string, unknown>;`,
		);
		toolsLines.push("    };");
	}

	toolsLines.push("  }");
	toolsLines.push("");

	// Export tool names as a union type
	if (tools.length > 0) {
		const toolNames = tools
			.map((t) => `"${t.name || t.relativePath.replace(/\.(ts|tsx)$/, "")}"`)
			.join(" | ");
		toolsLines.push(`  export type ToolName = ${toolNames};`);
	} else {
		toolsLines.push("  export type ToolName = never;");
	}

	toolsLines.push("}");
	toolsLines.push("");

	// Generate Resources interface
	const resourcesLines = [
		header,
		'declare module "chapplin:resources" {',
		"  export interface Resources {",
	];

	for (const resource of resources) {
		const resourceName =
			resource.name || resource.relativePath.replace(/\.ts$/, "");
		resourcesLines.push(`    "${resourceName}": {`);
		resourcesLines.push(`      uri: "${resource.uri || "unknown"}";`);
		resourcesLines.push("    };");
	}

	resourcesLines.push("  }");
	resourcesLines.push("");

	if (resources.length > 0) {
		const resourceNames = resources
			.map((r) => `"${r.name || r.relativePath.replace(/\.ts$/, "")}"`)
			.join(" | ");
		resourcesLines.push(`  export type ResourceName = ${resourceNames};`);
	} else {
		resourcesLines.push("  export type ResourceName = never;");
	}

	resourcesLines.push("}");
	resourcesLines.push("");

	// Generate Prompts interface
	const promptsLines = [
		header,
		'declare module "chapplin:prompts" {',
		"  export interface Prompts {",
	];

	for (const prompt of prompts) {
		const promptName = prompt.name || prompt.relativePath.replace(/\.ts$/, "");
		const importPath = `../${relative(root, prompt.path).replace(/\.ts$/, "")}`;

		promptsLines.push(`    "${promptName}": {`);
		promptsLines.push(
			`      args: typeof import("${importPath}").prompt.config extends { argsSchema: infer S } ? import("zod").infer<import("zod").ZodObject<S>> : Record<string, unknown>;`,
		);
		promptsLines.push("    };");
	}

	promptsLines.push("  }");
	promptsLines.push("");

	if (prompts.length > 0) {
		const promptNames = prompts
			.map((p) => `"${p.name || p.relativePath.replace(/\.ts$/, "")}"`)
			.join(" | ");
		promptsLines.push(`  export type PromptName = ${promptNames};`);
	} else {
		promptsLines.push("  export type PromptName = never;");
	}

	promptsLines.push("}");
	promptsLines.push("");

	return {
		mcpServer: mcpServerLines.join("\n"),
		tools: toolsLines.join("\n"),
		resources: resourcesLines.join("\n"),
		prompts: promptsLines.join("\n"),
	};
}
