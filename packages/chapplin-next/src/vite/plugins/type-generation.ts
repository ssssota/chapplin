import { mkdir, readFile, writeFile } from "node:fs/promises";
import { join, relative } from "node:path";
import type { Plugin, ResolvedConfig } from "vite";
import { VIRTUAL_MODULE_ID } from "../../constants.js";
import {
	parsePromptFile,
	parseResourceFile,
	parseToolFile,
} from "../parser.js";
import type { Options } from "../types.js";
import { resolveOptions } from "../utils.js";
import { getCollectedFiles } from "./file-collector.js";

/** Output directory for generated types */
const TYPE_GEN_DIR = ".chapplin";
const TYPE_GEN_FILE = "types.d.ts";

/**
 * Plugin that generates TypeScript type definitions
 */
export function typeGeneration(opts: Options): Plugin {
	const resolvedOpts = resolveOptions(opts);
	let config: ResolvedConfig;

	return {
		name: "chapplin:type-generation",
		configResolved(resolvedConfig) {
			config = resolvedConfig;
		},
		async buildStart() {
			const files = await getCollectedFiles();
			const root = config.root;

			// Parse all files to extract type information
			const toolInfos = await Promise.all(
				files.tools.map(async (tool) => {
					const code = await readFile(tool.path, "utf-8");
					const parsed = await parseToolFile(tool.path, code);
					return {
						...tool,
						...parsed,
					};
				}),
			);

			const resourceInfos = await Promise.all(
				files.resources.map(async (resource) => {
					const code = await readFile(resource.path, "utf-8");
					const parsed = await parseResourceFile(resource.path, code);
					return {
						...resource,
						...parsed,
					};
				}),
			);

			const promptInfos = await Promise.all(
				files.prompts.map(async (prompt) => {
					const code = await readFile(prompt.path, "utf-8");
					const parsed = await parsePromptFile(prompt.path, code);
					return {
						...prompt,
						...parsed,
					};
				}),
			);

			// Generate type definitions
			const typeContent = generateTypeDefinitions(
				root,
				toolInfos,
				resourceInfos,
				promptInfos,
			);

			// Write to .chapplin/types.d.ts
			const outputDir = join(root, TYPE_GEN_DIR);
			const outputPath = join(outputDir, TYPE_GEN_FILE);

			await mkdir(outputDir, { recursive: true });
			await writeFile(outputPath, typeContent, "utf-8");

			if (config.command === "serve") {
				config.logger.info(
					`[chapplin] Generated ${TYPE_GEN_DIR}/${TYPE_GEN_FILE}`,
				);
			}
		},
	};
}

interface ToolInfo {
	path: string;
	relativePath: string;
	name: string | null;
	hasApp: boolean;
	inputSchemaSource: string | null;
	outputSchemaSource: string | null;
}

interface ResourceInfo {
	path: string;
	relativePath: string;
	name: string | null;
	uri: string | null;
}

interface PromptInfo {
	path: string;
	relativePath: string;
	name: string | null;
	argsSchemaSource: string | null;
}

/**
 * Generate TypeScript type definitions
 */
function generateTypeDefinitions(
	root: string,
	tools: ToolInfo[],
	resources: ResourceInfo[],
	prompts: PromptInfo[],
): string {
	const lines: string[] = [
		"// This file is auto-generated by chapplin. Do not edit manually.",
		"// To regenerate, run `vite build` or `vite dev`",
		"",
	];

	// Generate module declaration for chapplin:mcp-server
	lines.push(`declare module "${VIRTUAL_MODULE_ID}" {`);
	lines.push(
		'  import type { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";',
	);
	lines.push("  /**");
	lines.push(
		"   * Create a new MCP server instance with all registered tools, resources, and prompts.",
	);
	lines.push(
		"   * Each call creates a fresh instance, which is needed for transports like StreamableHTTPTransport",
	);
	lines.push("   * that require a new server per request.");
	lines.push("   */");
	lines.push("  export function createMcpServer(): McpServer;");
	lines.push("  export default createMcpServer;");
	lines.push("}");
	lines.push("");

	// Generate Tools interface
	lines.push('declare module "chapplin:tools" {');
	lines.push("  export interface Tools {");

	for (const tool of tools) {
		const toolName = tool.name || tool.relativePath.replace(/\.(ts|tsx)$/, "");
		// Import types from the actual tool file
		const importPath = `../${relative(root, tool.path).replace(/\.(ts|tsx)$/, "")}`;

		lines.push(`    "${toolName}": {`);
		lines.push(`      /** Import path: ${importPath} */`);
		lines.push(
			`      input: typeof import("${importPath}").config extends { inputSchema: infer S } ? import("zod").infer<import("zod").ZodObject<S>> : Record<string, unknown>;`,
		);
		lines.push(
			`      output: typeof import("${importPath}").config extends { outputSchema: infer S } ? import("zod").infer<import("zod").ZodObject<S>> : Record<string, unknown>;`,
		);
		lines.push("    };");
	}

	lines.push("  }");
	lines.push("");

	// Export tool names as a union type
	if (tools.length > 0) {
		const toolNames = tools
			.map((t) => `"${t.name || t.relativePath.replace(/\.(ts|tsx)$/, "")}"`)
			.join(" | ");
		lines.push(`  export type ToolName = ${toolNames};`);
	} else {
		lines.push("  export type ToolName = never;");
	}

	lines.push("}");
	lines.push("");

	// Generate Resources interface
	lines.push('declare module "chapplin:resources" {');
	lines.push("  export interface Resources {");

	for (const resource of resources) {
		const resourceName =
			resource.name || resource.relativePath.replace(/\.ts$/, "");
		lines.push(`    "${resourceName}": {`);
		lines.push(`      uri: "${resource.uri || "unknown"}";`);
		lines.push("    };");
	}

	lines.push("  }");
	lines.push("");

	if (resources.length > 0) {
		const resourceNames = resources
			.map((r) => `"${r.name || r.relativePath.replace(/\.ts$/, "")}"`)
			.join(" | ");
		lines.push(`  export type ResourceName = ${resourceNames};`);
	} else {
		lines.push("  export type ResourceName = never;");
	}

	lines.push("}");
	lines.push("");

	// Generate Prompts interface
	lines.push('declare module "chapplin:prompts" {');
	lines.push("  export interface Prompts {");

	for (const prompt of prompts) {
		const promptName = prompt.name || prompt.relativePath.replace(/\.ts$/, "");
		const importPath = `../${relative(root, prompt.path).replace(/\.ts$/, "")}`;

		lines.push(`    "${promptName}": {`);
		lines.push(
			`      args: typeof import("${importPath}").config extends { argsSchema: infer S } ? import("zod").infer<import("zod").ZodObject<S>> : Record<string, unknown>;`,
		);
		lines.push("    };");
	}

	lines.push("  }");
	lines.push("");

	if (prompts.length > 0) {
		const promptNames = prompts
			.map((p) => `"${p.name || p.relativePath.replace(/\.ts$/, "")}"`)
			.join(" | ");
		lines.push(`  export type PromptName = ${promptNames};`);
	} else {
		lines.push("  export type PromptName = never;");
	}

	lines.push("}");
	lines.push("");

	return lines.join("\n");
}
